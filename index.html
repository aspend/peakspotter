<!DOCTYPE html>
<html>
<head>
    <title>Peaks Viewer</title>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // =====================
        // 1. CREATE WORLD
        // =====================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        scene.background = new THREE.Color(0xFFFFFF);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Default user location (fallback: your old hardcoded one)
        let user = { lat: 37.7380151, lon: -122.4299151 };

        // =====================
        // 2. CYLINDER + HORIZON
        // =====================
        const cylinderRadius = 100;
        const cylinderHeight = 100;
        const radialSegments = 360;

        const cylinderGeometry = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderHeight,
          radialSegments
        );
        const cylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        scene.add(cylinder);

        // Horizon line
        const linePoints = [];
        const lineRadius = cylinderRadius;
        const lineHeight = 0;

        for (let i = 0; i <= radialSegments; i++) {
          const angle = (i / radialSegments) * Math.PI * 2;
          const x = lineRadius * Math.cos(angle);
          const z = lineRadius * Math.sin(angle);
          linePoints.push(new THREE.Vector3(x, lineHeight, z));
        }

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        // =====================
        // 3. BEARING + DISTANCE HELPERS
        // =====================
        const toRad = d => d * Math.PI / 180;
        const toDeg = r => r * 180 / Math.PI;

        function compassBearingDeg(lat1, lon1, lat2, lon2) {
          const latr1 = toRad(lat1), latr2 = toRad(lat2);
          const dLon = toRad(lon2 - lon1);

          const y = Math.sin(dLon) * Math.cos(latr2);
          const x = Math.cos(latr1) * Math.sin(latr2) -
                    Math.sin(latr1) * Math.cos(latr2) * Math.cos(dLon);
          return (toDeg(Math.atan2(y, x)) + 360) % 360; // 0..360, 0 = North
        }

        const sceneBearingRad = bearing => THREE.MathUtils.degToRad(bearing - 90);

        function placePeakOnHorizon(obj, user, peak, radius, height = 2) {
          const brg = compassBearingDeg(user.lat, user.lon, peak.lat, peak.lon);
          const ang = sceneBearingRad(brg);

          obj.position.set(
            radius * Math.cos(ang),
            0, // base on horizon
            radius * Math.sin(ang)
          );

          obj.lookAt(0, 0, 0);
        }

        // Great-circle distance in meters
        function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
          const R = 6371000; // Earth radius in meters
          const φ1 = toRad(lat1);
          const φ2 = toRad(lat2);
          const Δφ = toRad(lat2 - lat1);
          const Δλ = toRad(lon2 - lon1);

          const a =
            Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);

          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        // Approximate vertical elevation angle from user → peak (radians)
        function verticalAngleRad(user, peak) {
          const userEle = user.ele || 0; // if you ever get real user elevation, put it here
          const peakEle = peak.ele || userEle;
          const d = haversineDistanceMeters(user.lat, user.lon, peak.lat, peak.lon);
          if (d === 0) return 0;
          const deltaH = peakEle - userEle; // height difference in meters
          return Math.atan2(deltaH, d);     // vertical angle above horizon
        }

        // Visibility / dominant peaks filter
        function filterVisiblePeaks(peaks, user, options = {}) {
          const binSizeDeg   = options.binSizeDeg   || 2;         // angular resolution
          const minAngleRad  = options.minAngleRad  ?? -Infinity; // set e.g. 0 to drop below-horizon peaks

          const withMeta = peaks.map(p => {
            const bearing = compassBearingDeg(user.lat, user.lon, p.lat, p.lon);
            const vAngle  = verticalAngleRad(user, p);
            return { ...p, bearing, vAngle };
          });

          const candidates = withMeta.filter(p => p.vAngle >= minAngleRad);

          const bestByBin = new Map();
          candidates.forEach(p => {
            const bin = Math.round(p.bearing / binSizeDeg) * binSizeDeg;
            const current = bestByBin.get(bin);
            if (!current || p.vAngle > current.vAngle) {
              bestByBin.set(bin, p);
            }
          });

          return Array.from(bestByBin.values());
        }

        // =====================
        // 4. PEAK GEOMETRY + LABELS
        // =====================
        function makeTrianglePeak(height, width, color = 0x000000, thickness = 1) {
          const halfW = width / 2;
          const points = [
            new THREE.Vector3(-halfW, 0, 0),
            new THREE.Vector3(0,      height, 0),
            new THREE.Vector3(halfW,  0, 0),
            new THREE.Vector3(-halfW, 0, 0),
          ];

          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const mat  = new THREE.LineBasicMaterial({
            color,
            linewidth: thickness   // may be ignored on some platforms
          });
          return new THREE.Line(geom, mat);
        }

        // NEW: filled, transparent triangle for shading
        function makeFilledPeakTriangle(height, width, color = 0x0000ff, opacity = 0.25) {
          const halfW = width / 2;

          const vertices = new Float32Array([
            -halfW, 0,     0,
             halfW, 0,     0,
             0,     height, 0
          ]);

          const geom = new THREE.BufferGeometry();
          geom.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

          const mat = new THREE.MeshBasicMaterial({
            color,
            transparent: true,
            opacity,
            depthWrite: false,      // so fills don't stack and darken each other as much
            side: THREE.DoubleSide
          });

          return new THREE.Mesh(geom, mat);
        }

        function makePeakLabel(
          name,
          subtitle,                 // e.g. "12.3 mi · 8,945 ft"
          color = "#000",
          {
            titleFontPx = 56,       // big main label size (CSS px)
            subtitleFontPx = 32,    // smaller line under it
            sizeWorld = 14,         // how big the sprite is in world units
            angleDeg = -90          // vertical
          } = {}
        ) {
          const dpr = window.devicePixelRatio || 1;

          const logicalSize = 512;               // canvas coords used in drawing
          const canvas = document.createElement("canvas");
          canvas.width  = logicalSize * dpr;     // actual pixel backing store
          canvas.height = logicalSize * dpr;

          const ctx = canvas.getContext("2d");

          // Map logical coordinates → hi-res backing store
          ctx.scale(dpr, dpr);

          ctx.clearRect(0, 0, logicalSize, logicalSize);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          const padding = 40;

          let titleSize   = titleFontPx;
          let subtitleSize = subtitleFontPx;

          const fontStack = 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';

          const setFonts = () => {
            ctx.font = `normal normal 600 ${titleSize}px ${fontStack}`;
          };

          setFonts();

          // Measure main text width and shrink if needed to avoid clipping when rotated
          const maxWidth = logicalSize - 2 * padding;
          let metrics = ctx.measureText(name);
          let textWidth = metrics.width;

          if (textWidth > maxWidth) {
            const scale = maxWidth / textWidth;
            titleSize    *= scale;
            subtitleSize *= scale;
          }

          // Draw rotated text (name + subtitle)
          ctx.save();
          ctx.translate(logicalSize / 2, logicalSize / 2);
          const angleRad = angleDeg * Math.PI / 180;
          ctx.rotate(angleRad);

          // Vertical offset between lines (in rotated space)
          const lineGap = titleSize * 0.9;

          // Title (top)
          ctx.font = `normal normal 600 ${titleSize}px ${fontStack}`;
          ctx.fillText(name, 0, -lineGap / 2);

          // Subtitle (bottom, smaller)
          if (subtitle) {
            ctx.font = `normal normal 400 ${subtitleSize}px ${fontStack}`;
            ctx.fillText(subtitle, 0, lineGap / 2 + subtitleSize * 0.1);
          }

          ctx.restore();

          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.anisotropy =
            (renderer.capabilities && renderer.capabilities.getMaxAnisotropy
              ? renderer.capabilities.getMaxAnisotropy()
              : 1);
          texture.needsUpdate = true;

          const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true
          });

          const sprite = new THREE.Sprite(material);

          // Taller than wide: fits the tilted two-line label nicely
          sprite.scale.set(sizeWorld, sizeWorld * 3, 1);

          return sprite;
        }

        // =====================
        // 5. OVERPASS API: FETCH PEAKS
        // =====================
        function fetchPeaksFromOverpass(lat, lon, radiusMeters = 50000) {
          const query = `
            [out:json][timeout:25];
            node["natural"="peak"](around:${radiusMeters},${lat},${lon});
            out body;
          `;

          return fetch("https://overpass-api.de/api/interpreter", {
            method: "POST",
            body: query
          }).then(res => res.json());
        }

        function buildPeaksFromOverpass(json) {
          if (!json.elements) return [];

          return json.elements
            .filter(el => el.type === "node")
            .map(el => {
              const tags = el.tags || {};
              const ele = tags.ele ? parseFloat(tags.ele) : null;

              return {
                name: tags.name || "Unnamed peak",
                lat: el.lat,
                lon: el.lon,
                ele: Number.isFinite(ele) ? ele : 1000, // fallback if no elevation
                color: 0x0000ff
              };
            });
        }

        // =====================
        // 6. DRAW PEAKS
        // =====================
        // Peaks are:
        //   - colored by distance: near = red, far = blue
        //   - thicker lines when near, thinner when far
        //   - shaded with transparent fills (more opaque when near)
        function drawPeaks(peaks) {
          if (!peaks.length) {
            console.warn("No peaks found from Overpass.");
            return;
          }

          const maxEle = Math.max(...peaks.map(p => p.ele || 1));

          // Color gradient: closest peaks = red, farthest peaks = blue
          const nearColor = new THREE.Color(0xff0000); // red (close)
          const farColor  = new THREE.Color(0x0000ff); // blue (far)

          // Precompute distance for each peak
          peaks.forEach(p => {
            const distMeters = haversineDistanceMeters(user.lat, user.lon, p.lat, p.lon);
            p._distMeters = distMeters;
          });

          const maxDist = Math.max(...peaks.map(p => p._distMeters || 1));

          peaks.forEach(p => {
            // 1) mountain visual size in world units
            const height = 10 * p.ele / maxEle;
            const width  = 3;

            // 2) distance -> 0..1   (t=0 near, t=1 far)
            const d = p._distMeters;
            const t = Math.min(1, d / maxDist);

            // 3) color from gradient
            const col = nearColor.clone().lerp(farColor, t);
            const colHex = col.getHex();

            // 4) line thickness based on distance
            const maxThickness = 6;  // closest
            const minThickness = 1;  // farthest
            const thickness = maxThickness - t * (maxThickness - minThickness);

            // 5) outline triangle
            const tri = makeTrianglePeak(height, width, colHex, thickness);
            scene.add(tri);
            placePeakOnHorizon(tri, user, p, lineRadius, height);

            // 6) transparent filled triangle for shading
            let shadeOpacity = 0.35 - 0.25 * t;           // 0.35 near → ~0.10 far
            shadeOpacity = Math.max(0.05, shadeOpacity);  // avoid fully invisible

            const shade = makeFilledPeakTriangle(height, width, colHex, shadeOpacity);
            shade.position.copy(tri.position);
            shade.rotation.copy(tri.rotation);
            shade.position.y -= 0.05; // nudge "behind" the line a bit
            scene.add(shade);

            // 7) find the peak TIP in world coordinates
            const tipLocal = new THREE.Vector3(0, height, 0);
            const tipWorld = tri.localToWorld(tipLocal.clone());

            // 8) label position (above the tip)
            const labelOffset = 30;
            const labelPos = tipWorld.clone().add(new THREE.Vector3(0, labelOffset, 0));

            // 9) line from peak tip to label
            const leaderGeom = new THREE.BufferGeometry().setFromPoints([
              tipWorld,
              labelPos
            ]);
            const leaderMat  = new THREE.LineBasicMaterial({ color: 0x000000 });
            const leaderLine = new THREE.Line(leaderGeom, leaderMat);
            scene.add(leaderLine);

            // 10) distance & elevation text for subtitle
            const distMiles = d / 1609.34;
            const distStr = distMiles.toFixed(1) + " mi";

            const eleMeters = p.ele || 0;
            const eleFeet = eleMeters * 3.28084;
            const eleStr = Math.round(eleFeet).toLocaleString() + " ft";

            const subtitle = `${distStr} · ${eleStr}`;

            // 11) label at the end of that line
            const label = makePeakLabel(p.name, subtitle, "#000");
            label.position.copy(labelPos);
            scene.add(label);
          });
        }

        // =====================
        // 7. GET USER LOCATION, THEN LOAD PEAKS
        // =====================
        function initPeaks() {
          const radiusMeters = 50000; // ~50 miles
          fetchPeaksFromOverpass(user.lat, user.lon, radiusMeters)
            .then(data => {
              let peaks = buildPeaksFromOverpass(data);

              // disregard peaks with no name / "unnamed"
              peaks = peaks.filter(p => p.name && !p.name.toLowerCase().includes("unnamed"));

              // reduce to “visible” / dominant peaks
              peaks = filterVisiblePeaks(peaks, user, {
                binSizeDeg: 2,      // try 1–5° and see what looks good
                minAngleRad: 0      // 0 = only above-horizon; use -Infinity to keep all
              });

              console.log("Peaks after visibility filter:", peaks.length);
              drawPeaks(peaks);
            })
            .catch(err => {
              console.error("Error fetching peaks from Overpass:", err);
            });
        }

        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            pos => {
              user = {
                lat: pos.coords.latitude,
                lon: pos.coords.longitude
              };
              initPeaks();
            },
            err => {
              console.warn("Geolocation failed, using default location:", err);
              initPeaks();
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
          );
        } else {
          console.warn("Geolocation not supported, using default location.");
          initPeaks();
        }

        // =====================
        // 8. COMPASS INDICATORS (N/E/S/W)
        // =====================
        function makeDirectionIndicators(letter, color = "#000", fontPx = 72, size = 18) {
          const canvas = document.createElement("canvas");
          canvas.width = canvas.height = 256;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, 256, 256);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${fontPx}px sans-serif`;
          ctx.fillText(letter, 128, 128);

          const tex = new THREE.CanvasTexture(canvas);
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide
          });

          const geo = new THREE.PlaneGeometry(size, size);
          return new THREE.Mesh(geo, mat);
        }

        const dirs = [
          { label: "N", bearing: 0   },
          { label: "E", bearing: 90  },
          { label: "S", bearing: 180 },
          { label: "W", bearing: 270 }
        ];

        dirs.forEach(d => {
          const mesh = makeDirectionIndicators(d.label);
          const ang = sceneBearingRad(d.bearing);
          const r = lineRadius;

          mesh.position.set(
            r * Math.cos(ang),
            0,
            r * Math.sin(ang)
          );

          mesh.lookAt(0, 0, 0);
          scene.add(mesh);
        });

        // =====================
        // 9. RENDER LOOP
        // =====================
        function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        }
        animate();

        // =====================
        // 10. DEVICE ORIENTATION → CAMERA
        // =====================
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const quaternion = new THREE.Quaternion();
        const screenOrientationQuaternion = new THREE.Quaternion();
        const zAxis = new THREE.Vector3(0, 0, 1);

        const q1 = new THREE.Quaternion().setFromAxisAngle(
          new THREE.Vector3(1, 0, 0),
          -Math.PI / 2
        );

        function onDeviceOrientation(event) {
          if (event.alpha == null) return;

          const alphaRad = THREE.MathUtils.degToRad(event.alpha);
          const betaRad  = THREE.MathUtils.degToRad(event.beta);
          const gammaRad = THREE.MathUtils.degToRad(event.gamma);

          const screenAngle =
            (screen.orientation && screen.orientation.angle) || window.orientation || 0;
          const screenAngleRad = THREE.MathUtils.degToRad(screenAngle);

          euler.set(betaRad, alphaRad, -gammaRad, 'YXZ');
          quaternion.setFromEuler(euler);

          quaternion.multiply(q1);

          screenOrientationQuaternion.setFromAxisAngle(zAxis, -screenAngleRad);
          quaternion.multiply(screenOrientationQuaternion);

          camera.quaternion.copy(quaternion);
        }

        window.addEventListener('deviceorientationabsolute', onDeviceOrientation, { passive: true });
    </script>
</body>
</html>
