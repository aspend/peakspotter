<!DOCTYPE html>
<html>
<head>
    <title>Three.js CDN Example</title>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Create World
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        scene.background = new THREE.Color(0xFFFFFF)
        renderer.setSize(window.innerWidth, window.innerHeight);

        document.body.appendChild(renderer.domElement);


        // Draw cylinder

        const cylinderRadius = 100;
        const cylinderHeight = 100;
        const radialSegments = 360; // More segments for a smoother cylinder
        const cylinderGeometry = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, radialSegments);
        const cylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc}); //  wireframe: true 
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        scene.add(cylinder);


        // Draw horizon

        const linePoints = [];
        const lineRadius = cylinderRadius; 
        const lineHeight = 0; // at the horizon

        for (let i = 0; i <= radialSegments; i++) {
                const angle = (i / radialSegments) * Math.PI * 2;
                const x = lineRadius * Math.cos(angle);
                const z = lineRadius * Math.sin(angle);
                linePoints.push(new THREE.Vector3(x, lineHeight, z));
            }

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 }); // Red line, thickness 2
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
        

        // Calculate position using current lat/long and peak lat long
        // //Calculate bearing from user to peak
        const toRad = d => d * Math.PI / 180;
        const toDeg = r => r * 180 / Math.PI;

        function compassBearingDeg(lat1, lon1, lat2, lon2) {
          const latr1 = toRad(lat1), latr2 = toRad(lat2);
          const y = Math.sin(toRad(lon2 - lon1)) * Math.cos(latr2);
          const x = Math.cos(latr1)*Math.sin(latr2) - Math.sin(latr1)*Math.cos(latr2)*Math.cos(toRad(lon2 - lon1));
          return (toDeg(Math.atan2(y, x)) + 360) % 360; // 0..360 where 0 is North
        }

        const sceneBearingRad = bearing => THREE.MathUtils.degToRad(bearing); // convert compass bearing to scene bearing

        // //function to place the cone
        function placePeakOnHorizon(cone, user, peak, radius, coneHeight=2) {
          const brg = compassBearingDeg(user.lat, user.lon, peak.lat, peak.lon); // degrees
          const ang = sceneBearingRad(brg);                                  // radians

          // Base on horizon: lift by half height so rim sits at y=0
          cone.position.set(
            radius * Math.cos(ang),
            coneHeight / 2,
            radius * Math.sin(ang)
          );

          // Make cone “face” inward like a marker
          cone.lookAt(0, cone.position.y, 0);
        }


        // //draw mountains
        const user = { lat: 37.7380151, lon: -122.4299151 }; // you
        const peaks = [ 
                        { name: "Mt Tam", lat: 37.923063, lon: -122.6162559, color: 0x0000ff }, // blue
                        { name: "Mt Diablo", lat: 37.8818613, lon: -121.9193885, color: 0xff0000 }, // red
                      ];

        function makePeakLabel(text, color = "#000", fontPx = 50, size = 10) {
          const canvas = document.createElement("canvas");
          canvas.width = canvas.height = 256;
          const ctx = canvas.getContext("2d");

          ctx.clearRect(0, 0, 256, 256);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${fontPx}px sans-serif`;
          ctx.fillText(text, 128, 128);

          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
          const sprite = new THREE.Sprite(material);

          sprite.scale.set(size, size * 2, 2); // tweak size as needed
          return sprite;
        }

        peaks.forEach(p => {
          const coneHeight = 2;
          const cone = new THREE.Mesh(
            new THREE.ConeGeometry(1, coneHeight, 16),
            new THREE.MeshBasicMaterial({ color: p.color })
          );
          scene.add(cone);
          placePeakOnHorizon(cone, user, p, lineRadius, coneHeight);

          // draw label

          const label = makePeakLabel(p.name, "#000");
          label.position.copy(cone.position);
          label.position.y += coneHeight + 2; // a bit above the tip
          scene.add(label);
        });


        // Add compass direction indicators to horizon

        function makeDirectionIndicators(letter, color = "#000", fontPx = 72, size = 18) {
          const canvas = document.createElement("canvas");
          canvas.width = canvas.height = 256;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, 256, 256);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${fontPx}px sans-serif`;
          ctx.fillText(letter, 128, 128); // letters centered on horizon

          const tex = new THREE.CanvasTexture(canvas);
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide
          });

          const geo = new THREE.PlaneGeometry(size, size);
          const mesh = new THREE.Mesh(geo, mat);
          return mesh;
        }

        const dirs = [
          { label: "N", bearing: 0   },
          { label: "E", bearing: 90  },
          { label: "S", bearing: 180 },
          { label: "W", bearing: 270 }
        ];

        dirs.forEach(d => {
          const mesh = makeDirectionIndicators(d.label);
          const ang = sceneBearingRad(d.bearing);
          const r = lineRadius;

          // position on horizon ring
          mesh.position.set(
            r * Math.cos(ang),
            0, // exactly on the horizon
            r * Math.sin(ang)
          );

          // orient so the letter faces the center (radially)
          mesh.lookAt(0, 0, 0);

          scene.add(mesh);
        });


        // Render world

        function animate() {
            requestAnimationFrame(animate);
            // cylinder.rotation.x += 0.01;
            // cylinder.rotation.z += 0.01;
            renderer.render(scene, camera);
        }
        animate();


        // Orient world rotation with device rotation


        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const quaternion = new THREE.Quaternion();
        const screenOrientationQuaternion = new THREE.Quaternion();
        const zAxis = new THREE.Vector3(0, 0, 1);

        // // Rotate -90° about X so device "forward" aligns with camera -Z
        const q1 = new THREE.Quaternion().setFromAxisAngle(
          new THREE.Vector3(1, 0, 0),
          -Math.PI / 2
        );



        function onDeviceOrientation(event) {
          if (event.alpha == null) return;

          const alphaRad = THREE.MathUtils.degToRad(event.alpha);
          const betaRad  = THREE.MathUtils.degToRad(event.beta);
          const gammaRad = THREE.MathUtils.degToRad(event.gamma);

          // Use modern API if available; fall back to window.orientation
          const screenAngle =
            (screen.orientation && screen.orientation.angle) || window.orientation || 0;
          const screenAngleRad = THREE.MathUtils.degToRad(screenAngle);

          // Device -> quaternion
          euler.set(betaRad, alphaRad, -gammaRad, 'YXZ');
          quaternion.setFromEuler(euler);

          // FIX: align device frame to Three.js camera frame
          quaternion.multiply(q1);

          // Compensate screen rotation
          screenOrientationQuaternion.setFromAxisAngle(zAxis, -screenAngleRad);
          quaternion.multiply(screenOrientationQuaternion);

          camera.quaternion.copy(quaternion);
        }

        window.addEventListener('deviceorientation', onDeviceOrientation, { passive: true });

    </script>
</body>
</html>
