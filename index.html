<!DOCTYPE html>
<html>
<head>
    <title>Three.js Peaks Viewer</title>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // =====================
        // 1. CREATE WORLD
        // =====================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        scene.background = new THREE.Color(0xFFFFFF);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Default user location (fallback: your old hardcoded one)
        let user = { lat: 37.7380151, lon: -122.4299151 };

        // =====================
        // 2. CYLINDER + HORIZON
        // =====================
        const cylinderRadius = 100;
        const cylinderHeight = 100;
        const radialSegments = 360;

        const cylinderGeometry = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderHeight,
          radialSegments
        );
        const cylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        scene.add(cylinder);

        // Horizon line
        const linePoints = [];
        const lineRadius = cylinderRadius;
        const lineHeight = 0;

        for (let i = 0; i <= radialSegments; i++) {
          const angle = (i / radialSegments) * Math.PI * 2;
          const x = lineRadius * Math.cos(angle);
          const z = lineRadius * Math.sin(angle);
          linePoints.push(new THREE.Vector3(x, lineHeight, z));
        }

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        // =====================
        // 3. BEARING HELPERS
        // =====================
        const toRad = d => d * Math.PI / 180;
        const toDeg = r => r * 180 / Math.PI;

        function compassBearingDeg(lat1, lon1, lat2, lon2) {
          const latr1 = toRad(lat1), latr2 = toRad(lat2);
          const dLon = toRad(lon2 - lon1);

          const y = Math.sin(dLon) * Math.cos(latr2);
          const x = Math.cos(latr1) * Math.sin(latr2) -
                    Math.sin(latr1) * Math.cos(latr2) * Math.cos(dLon);
          return (toDeg(Math.atan2(y, x)) + 360) % 360; // 0..360, 0 = North
        }

        const sceneBearingRad = bearing => THREE.MathUtils.degToRad(bearing - 90);

        function placePeakOnHorizon(obj, user, peak, radius, height = 2) {
          const brg = compassBearingDeg(user.lat, user.lon, peak.lat, peak.lon);
          const ang = sceneBearingRad(brg);

          obj.position.set(
            radius * Math.cos(ang),
            0, // base on horizon
            radius * Math.sin(ang)
          );

          obj.lookAt(0, 0, 0);
        }

        // =====================
        // 4. PEAK GEOMETRY + LABELS
        // =====================
        function makeTrianglePeak(height, width, color = 0x000000) {
          const halfW = width / 2;
          const points = [
            new THREE.Vector3(-halfW, 0, 0),
            new THREE.Vector3(0,      height, 0),
            new THREE.Vector3(halfW,  0, 0),
            new THREE.Vector3(-halfW, 0, 0),
          ];

          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const mat  = new THREE.LineBasicMaterial({ color });
          return new THREE.Line(geom, mat);
        }

        function makePeakLabel(text, color = "#000", fontPx = 50, size = 10) {
          const canvas = document.createElement("canvas");
          canvas.width = canvas.height = 256;
          const ctx = canvas.getContext("2d");

          ctx.clearRect(0, 0, 256, 256);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${fontPx}px sans-serif`;
          ctx.fillText(text, 128, 128);

          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
          const sprite = new THREE.Sprite(material);

          sprite.scale.set(size, size * 2, 2);
          return sprite;
        }

        // =====================
        // 5. OVERPASS API: FETCH PEAKS
        // =====================

        // Fetch "natural=peak" within radiusMeters of (lat, lon)
        function fetchPeaksFromOverpass(lat, lon, radiusMeters = 80000) {
          const query = `
            [out:json][timeout:25];
            node["natural"="peak"](around:${radiusMeters},${lat},${lon});
            out body;
          `;

          return fetch("https://overpass-api.de/api/interpreter", {
            method: "POST",
            body: query
          }).then(res => res.json());
        }

        // Convert Overpass JSON -> peaks array in your format
        function buildPeaksFromOverpass(json) {
          if (!json.elements) return [];

          return json.elements
            .filter(el => el.type === "node")
            .map(el => {
              const tags = el.tags || {};
              const ele = tags.ele ? parseFloat(tags.ele) : null;

              return {
                name: tags.name || "Unnamed peak",
                lat: el.lat,
                lon: el.lon,
                ele: Number.isFinite(ele) ? ele : 1000, // fallback if no elevation
                color: 0x0000ff
              };
            });
        }

        // Draw peaks (triangles + labels) once we have them
        function drawPeaks(peaks) {
          if (!peaks.length) {
            console.warn("No peaks found from Overpass.");
            return;
          }

          const maxEle = Math.max(...peaks.map(p => p.ele || 1));

          peaks.forEach(p => {
            const height = 10 * (p.ele / maxEle); // same idea as before
            const width  = 3;

            const tri = makeTrianglePeak(height, width, p.color || 0x0000ff);
            scene.add(tri);
            placePeakOnHorizon(tri, user, p, lineRadius, height);

            const label = makePeakLabel(p.name, "#000");
            label.position.copy(tri.position);
            label.position.y += height + 2;
            scene.add(label);
          });
        }

        // =====================
        // 6. GET USER LOCATION, THEN LOAD PEAKS
        // =====================
        function initPeaks() {
          const radiusMeters = 80000; // ~50 miles
          fetchPeaksFromOverpass(user.lat, user.lon, radiusMeters)
            .then(data => {
              const peaks = buildPeaksFromOverpass(data);
              drawPeaks(peaks);
            })
            .catch(err => {
              console.error("Error fetching peaks from Overpass:", err);
            });
        }

        // Try to get real device location; fall back to default if denied
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            pos => {
              user = {
                lat: pos.coords.latitude,
                lon: pos.coords.longitude
              };
              initPeaks();
            },
            err => {
              console.warn("Geolocation failed, using default location:", err);
              initPeaks();
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
          );
        } else {
          console.warn("Geolocation not supported, using default location.");
          initPeaks();
        }

        // =====================
        // 7. COMPASS INDICATORS (N/E/S/W)
        // =====================
        function makeDirectionIndicators(letter, color = "#000", fontPx = 72, size = 18) {
          const canvas = document.createElement("canvas");
          canvas.width = canvas.height = 256;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, 256, 256);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${fontPx}px sans-serif`;
          ctx.fillText(letter, 128, 128);

          const tex = new THREE.CanvasTexture(canvas);
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide
          });

          const geo = new THREE.PlaneGeometry(size, size);
          return new THREE.Mesh(geo, mat);
        }

        const dirs = [
          { label: "N", bearing: 0   },
          { label: "E", bearing: 90  },
          { label: "S", bearing: 180 },
          { label: "W", bearing: 270 }
        ];

        dirs.forEach(d => {
          const mesh = makeDirectionIndicators(d.label);
          const ang = sceneBearingRad(d.bearing);
          const r = lineRadius;

          mesh.position.set(
            r * Math.cos(ang),
            0,
            r * Math.sin(ang)
          );

          mesh.lookAt(0, 0, 0);
          scene.add(mesh);
        });

        // =====================
        // 8. RENDER LOOP
        // =====================
        function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        }
        animate();

        // =====================
        // 9. DEVICE ORIENTATION â†’ CAMERA
        // =====================
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const quaternion = new THREE.Quaternion();
        const screenOrientationQuaternion = new THREE.Quaternion();
        const zAxis = new THREE.Vector3(0, 0, 1);

        const q1 = new THREE.Quaternion().setFromAxisAngle(
          new THREE.Vector3(1, 0, 0),
          -Math.PI / 2
        );

        function onDeviceOrientation(event) {
          if (event.alpha == null) return;

          const alphaRad = THREE.MathUtils.degToRad(event.alpha);
          const betaRad  = THREE.MathUtils.degToRad(event.beta);
          const gammaRad = THREE.MathUtils.degToRad(event.gamma);

          const screenAngle =
            (screen.orientation && screen.orientation.angle) || window.orientation || 0;
          const screenAngleRad = THREE.MathUtils.degToRad(screenAngle);

          euler.set(betaRad, alphaRad, -gammaRad, 'YXZ');
          quaternion.setFromEuler(euler);

          quaternion.multiply(q1);

          screenOrientationQuaternion.setFromAxisAngle(zAxis, -screenAngleRad);
          quaternion.multiply(screenOrientationQuaternion);

          camera.quaternion.copy(quaternion);
        }

        window.addEventListener('deviceorientation', onDeviceOrientation, { passive: true });
    </script>
</body>
</html>
