<!DOCTYPE html>
<html>
<head>
    <title>Peaks Viewer</title>
    <style>
      #status-indicator {
        position: fixed;
        top: 12px;
        right: 12px;
        z-index: 9999;
        background: rgba(255,255,255,0.92);
        border: 1px solid rgba(0,0,0,0.12);
        border-radius: 999px;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        font-size: 14px;
        box-shadow: 0 4px 14px rgba(0,0,0,0.12);
        user-select: none;
      }

      /* Spinner */
      .spinner {
        width: 14px;
        height: 14px;
        border: 2px solid rgba(0,0,0,0.15);
        border-top-color: rgba(0,0,0,0.6);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      /* Hide spinner when not loading */
      #status-indicator.done .spinner {
        display: none;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      #location-panel {
        position: fixed;
        left: 50%;
        bottom: 24px;
        transform: translateX(-50%);
        background: rgba(255,255,255,0.97);
        border-radius: 16px;              /* rounder corners */
        padding: 16px 20px;               /* more breathing room */
        box-shadow: 0 4px 16px rgba(0,0,0,0.18);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        font-size: 18px;                  /* bigger text */
        display: none;
        z-index: 10;
      }

      #location-panel label {
        margin-right: 6px;
      }

      #location-panel input {
        width: 200px;                     /* roughly 2x wider */
        margin: 6px 8px 6px 0;
        padding: 6px 8px;                 /* taller & more comfy */
        font-size: 16px;                  /* larger input text */
        border-radius: 10px;
        border: 1px solid #ccc;
        outline: none;
      }

      #location-panel input:focus {
        border-color: #007aff;
        box-shadow: 0 0 0 2px rgba(0,122,255,0.15);
      }

      #location-panel button {
        margin: 6px 8px 0 0;
        padding: 6px 12px;
        font-size: 16px;
        cursor: pointer;
        border-radius: 999px;             /* pill-shaped buttons */
        border: 1px solid #007aff;
        background: #007aff;
        color: #fff;
      }

      #location-panel button#reset-location {
        background: #ffffff;
        color: #007aff;
      }

      #location-panel button:active {
        transform: translateY(1px);
      }
      .latlon-row {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: nowrap;
      }

      .latlon-row label {
        margin-right: 4px;
        white-space: nowrap;
      }

      .latlon-row input {
        width: 140px;   /* tweak to taste */
      }

    </style>

</head>
<body>
  <div id="status-indicator">
    <div class="spinner"></div>
    <span class="status-text">Loading</span>
  </div>
    <!-- Panel that appears when phone points down -->
    <div id="location-panel">
      <div style="margin-bottom:4px; font-weight:600;">Set location</div>
      <div style="margin-top:6px;">
        <label for="place-input">Place:</label>
        <input id="place-input" type="text" placeholder="Address or city">
      </div>
      <div class="latlon-row">
        <label for="lat-input">Lat:</label>
        <input id="lat-input" type="number" step="0.000001">

        <label for="lon-input">Lon:</label>
        <input id="lon-input" type="number" step="0.000001">
      </div>
      <div style="margin-top:4px;">
        <button id="apply-location">Apply</button>
        <button id="reset-location">Reset to device</button>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Peak loading status indicator

        const statusEl = document.getElementById("status-indicator");
        const statusTextEl = statusEl?.querySelector(".status-text");

        function setStatusLoading(msg = "Loading") {
          if (!statusEl || !statusTextEl) return;
          statusEl.classList.remove("done");
          statusTextEl.textContent = msg;
        }

        function setStatusCount(n) {
          if (!statusEl || !statusTextEl) return;
          statusEl.classList.add("done");   // hides spinner
          statusTextEl.textContent = `${n} peak${n === 1 ? "" : "s"} found`;
        }

        function setStatusError(msg = "Error") {
          if (!statusEl || !statusTextEl) return;
          statusEl.classList.add("done");
          statusTextEl.textContent = msg;
        }

        // =====================
        // 1. CREATE WORLD
        // =====================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        scene.background = new THREE.Color(0xFFFFFF);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Default user location (fallback)
        let user = { lat: 37.7380151, lon: -122.4299151 };

        // UI elements for location panel
        const locationPanel = document.getElementById('location-panel');
        const latInput      = document.getElementById('lat-input');
        const lonInput      = document.getElementById('lon-input');
        if (latInput) latInput.value = "";
        if (lonInput) lonInput.value = "";
        const placeInput    = document.getElementById('place-input');
        const applyBtn      = document.getElementById('apply-location');
        const resetBtn      = document.getElementById('reset-location');

        function updateLocationInputs(force = false) {
          if (!latInput || !lonInput) return;

          if (!force) return; // don't auto-fill unless explicitly requested

          if (typeof user.lat === "number") latInput.value = user.lat.toFixed(6);
          if (typeof user.lon === "number") lonInput.value = user.lon.toFixed(6);
        }

        // Store peak objects for interaction
        const peakObjects = [];
        let selectedPeakEntry = null;

        // Raycaster for clicks
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // =====================
        // 2. CYLINDER + HORIZON
        // =====================
        const cylinderRadius = 100;
        const cylinderHeight = 100;
        const radialSegments = 360;

        const cylinderGeometry = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderHeight,
          radialSegments
        );
        const cylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        scene.add(cylinder);

        // Horizon line
        const linePoints = [];
        const lineRadius = cylinderRadius;
        const lineHeight = 0;

        for (let i = 0; i <= radialSegments; i++) {
          const angle = (i / radialSegments) * Math.PI * 2;
          const x = lineRadius * Math.cos(angle);
          const z = lineRadius * Math.sin(angle);
          linePoints.push(new THREE.Vector3(x, lineHeight, z));
        }

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        // =====================
        // 3. BEARING + DISTANCE HELPERS
        // =====================
        const toRad = d => d * Math.PI / 180;
        const toDeg = r => r * 180 / Math.PI;

        function compassBearingDeg(lat1, lon1, lat2, lon2) {
          const latr1 = toRad(lat1), latr2 = toRad(lat2);
          const dLon = toRad(lon2 - lon1);

          const y = Math.sin(dLon) * Math.cos(latr2);
          const x = Math.cos(latr1) * Math.sin(latr2) -
                    Math.sin(latr1) * Math.cos(latr2) * Math.cos(dLon);
          return (toDeg(Math.atan2(y, x)) + 360) % 360; // 0..360, 0 = North
        }

        const sceneBearingRad = bearing => THREE.MathUtils.degToRad(bearing - 90);

        function placePeakOnHorizon(obj, user, peak, radius, height = 2) {
          const brg = compassBearingDeg(user.lat, user.lon, peak.lat, peak.lon);
          const ang = sceneBearingRad(brg);

          obj.position.set(
            radius * Math.cos(ang),
            0, // base on horizon
            radius * Math.sin(ang)
          );

          obj.lookAt(0, 0, 0);
        }

        // Great-circle distance in meters
        function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
          const R = 6371000; // Earth radius in meters
          const φ1 = toRad(lat1);
          const φ2 = toRad(lat2);
          const Δφ = toRad(lat2 - lat1);
          const Δλ = toRad(lon2 - lon1);

          const a =
            Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);

          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        // Approximate vertical elevation angle from user → peak (radians)
        function verticalAngleRad(user, peak) {
          const userEle = user.ele || 0;
          const peakEle = peak.ele || userEle;
          const d = haversineDistanceMeters(user.lat, user.lon, peak.lat, peak.lon);
          if (d === 0) return 0;
          const deltaH = peakEle - userEle;
          return Math.atan2(deltaH, d);
        }

        // Visibility / dominant peaks filter
        function filterVisiblePeaks(peaks, user, options = {}) {
          const binSizeDeg   = options.binSizeDeg   || 2;
          const minAngleRad  = options.minAngleRad  ?? -Infinity;

          const withMeta = peaks.map(p => {
            const bearing = compassBearingDeg(user.lat, user.lon, p.lat, p.lon);
            const vAngle  = verticalAngleRad(user, p);
            return { ...p, bearing, vAngle };
          });

          const candidates = withMeta.filter(p => p.vAngle >= minAngleRad);

          const bestByBin = new Map();
          candidates.forEach(p => {
            const bin = Math.round(p.bearing / binSizeDeg) * binSizeDeg;
            const current = bestByBin.get(bin);
            if (!current || p.vAngle > current.vAngle) {
              bestByBin.set(bin, p);
            }
          });

          return Array.from(bestByBin.values());
        }


        // Convert manual location input to  lat lon

        async function geocodePlaceToLatLon(query) {
          const url =
            "https://nominatim.openstreetmap.org/search?format=json&limit=1&q=" +
            encodeURIComponent(query);

          const res = await fetch(url, {
            headers: { "Accept": "application/json" }
          });

          const data = await res.json();
          if (!data || !data.length) return null;

          return {
            lat: parseFloat(data[0].lat),
            lon: parseFloat(data[0].lon)
          };
        }


        // =====================
        // 4. PEAK GEOMETRY + LABELS
        // =====================

        // Text rotation inside the texture (degrees). 30 = fixed diagonal.
        const LABEL_ANGLE_DEG = -90;

        function makeTrianglePeak(height, width, color = 0x000000, thickness = 1) {
          const halfW = width / 2;
          const points = [
            new THREE.Vector3(-halfW, 0, 0),
            new THREE.Vector3(0,      height, 0),
            new THREE.Vector3(halfW,  0, 0),
            new THREE.Vector3(-halfW, 0, 0),
          ];

          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const mat  = new THREE.LineBasicMaterial({
            color,
            linewidth: thickness // may be ignored on some platforms
          });
          return new THREE.Line(geom, mat);
        }

        // Filled, transparent triangle for shading
        function makeFilledPeakTriangle(height, width, color = 0x0000ff, opacity = 0.25) {
          const halfW = width / 2;

          const vertices = new Float32Array([
            -halfW, 0,     0,
             halfW, 0,     0,
             0,     height, 0
          ]);

          const geom = new THREE.BufferGeometry();
          geom.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

          const mat = new THREE.MeshBasicMaterial({
            color,
            transparent: true,
            opacity,
            depthWrite: false,
            side: THREE.DoubleSide
          });

          return new THREE.Mesh(geom, mat);
        }

        // Helper: build label texture only (same font look as before)
        function buildPeakLabelTexture(
          name,
          subtitle,
          color = "#000",
          {
            titleFontPx = 56,
            subtitleFontPx = 32,
            angleDeg = LABEL_ANGLE_DEG,
          } = {}
        ) {
          const dpr = window.devicePixelRatio || 1;
          const logicalSize = 512;

          const canvas = document.createElement("canvas");
          canvas.width  = logicalSize * dpr;
          canvas.height = logicalSize * dpr;

          const ctx = canvas.getContext("2d");
          ctx.scale(dpr, dpr);

          ctx.clearRect(0, 0, logicalSize, logicalSize);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          const padding = 40;
          let titleSize   = titleFontPx;
          let subtitleSize = subtitleFontPx;
          const fontStack = 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';

          ctx.font = `normal normal 600 ${titleSize}px ${fontStack}`;

          const maxWidth = logicalSize - 2 * padding;
          let metrics = ctx.measureText(name);
          let textWidth = metrics.width;

          if (textWidth > maxWidth) {
            const scale = maxWidth / textWidth;
            titleSize    *= scale;
            subtitleSize *= scale;
          }

          ctx.save();
          ctx.translate(logicalSize / 2, logicalSize / 2);
          const angleRad = angleDeg * Math.PI / 180;
          ctx.rotate(angleRad);

          const lineGap = titleSize * 0.9;

          ctx.font = `normal normal 600 ${titleSize}px ${fontStack}`;
          ctx.fillText(name, 0, -lineGap / 2);

          if (subtitle) {
            ctx.font = `normal normal 400 ${subtitleSize}px ${fontStack}`;
            ctx.fillText(subtitle, 0, lineGap / 2 + subtitleSize * 0.1);
          }

          ctx.restore();

          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.anisotropy =
            (renderer.capabilities && renderer.capabilities.getMaxAnisotropy
              ? renderer.capabilities.getMaxAnisotropy()
              : 1);
          texture.needsUpdate = true;

          return texture;
        }

        // Build a 3D label as a plane (NOT a sprite) so it doesn't billboard
        function makePeakLabel(
          name,
          subtitle,
          color = "#000",
          {
            sizeWorld = 14,
            angleDeg = LABEL_ANGLE_DEG,
          } = {}
        ) {
          const texture = buildPeakLabelTexture(name, subtitle, color, { angleDeg });

          const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide
          });

          // Use texture aspect ratio to size the plane
          const img = texture.image;
          const aspect = (img && img.width && img.height) ? img.width / img.height : 1;

          const widthWorld = sizeWorld;
          const heightWorld = sizeWorld / aspect;

          const geometry = new THREE.PlaneGeometry(widthWorld, heightWorld);
          const mesh = new THREE.Mesh(geometry, material);
          return mesh;
        }

        // Update label style (color + font sizes) by rebuilding texture
        function setEntryLabelStyle(
          entry,
          cssColor,
          titleFontPx = 56,
          subtitleFontPx = 32
        ) {
          const tex = buildPeakLabelTexture(entry.data.name, entry.subtitle, cssColor, {
            titleFontPx,
            subtitleFontPx,
            angleDeg: LABEL_ANGLE_DEG
          });
          if (entry.label.material.map) entry.label.material.map.dispose();
          entry.label.material.map = tex;
          entry.label.material.needsUpdate = true;
        }

        // =====================
        // 5. OVERPASS API: FETCH PEAKS
        // =====================
        function fetchPeaksFromOverpass(lat, lon, radiusMeters = 50000) {
          const query = `
            [out:json][timeout:25];
            node["natural"="peak"](around:${radiusMeters},${lat},${lon});
            out body;
          `;
          return fetch("https://overpass-api.de/api/interpreter", {
            method: "POST",
            body: query
          }).then(res => res.json());
        }

        function buildPeaksFromOverpass(json) {
          if (!json.elements) return [];

          return json.elements
            .filter(el => 
              el.type === "node" &&
              el.tags && 
              el.tags.wikidata               // <-- only keep peaks with wikidata
            )
            .map(el => {
              const tags = el.tags || {};
              const ele = tags.ele ? parseFloat(tags.ele) : null;

              return {
                name: tags.name || "Unnamed peak",
                lat: el.lat,
                lon: el.lon,
                ele: Number.isFinite(ele) ? ele : 1000,
                color: 0x0000ff,
                wikidata: tags.wikidata      // optional: keep wikidata if you want it later
              };
            });
        }


        // =====================
        // 6. CLEAR PEAKS
        // =====================
        function clearPeaks() {
          peakObjects.forEach(entry => {
            scene.remove(entry.tri);
            scene.remove(entry.shade);
            scene.remove(entry.leaderLine);
            scene.remove(entry.label);

            entry.tri.geometry.dispose();
            entry.tri.material.dispose();
            entry.shade.geometry.dispose();
            entry.shade.material.dispose();
            entry.leaderLine.geometry.dispose();
            entry.leaderLine.material.dispose();

            if (entry.label.material.map) entry.label.material.map.dispose();
            entry.label.geometry.dispose();
            entry.label.material.dispose();
          });
          peakObjects.length = 0;
          selectedPeakEntry = null;
        }

        // =====================
        // 7. SELECTION APPEARANCE
        // =====================
        function applySelection(selectedEntry) {
          if (!selectedEntry) {
            // No selection: restore full color + normal labels
            peakObjects.forEach(entry => {
              entry.tri.material.color.set(entry.baseColor);
              entry.tri.material.needsUpdate = true;

              entry.shade.material.color.set(entry.baseColor);
              entry.shade.material.opacity = entry.baseOpacity;
              entry.shade.material.needsUpdate = true;

              setEntryLabelStyle(entry, entry.labelBaseColor); // default font sizes
            });
            selectedPeakEntry = null;
            return;
          }

          // There is a selected entry
          peakObjects.forEach(entry => {
            const isSelected = (entry === selectedEntry);

            if (isSelected) {
              // keep original distance-based color & opacity
              entry.tri.material.color.set(entry.baseColor);
              entry.shade.material.color.set(entry.baseColor);
              entry.shade.material.opacity = entry.baseOpacity;

              // BIGGER font for selected peak: name + subtitle
              setEntryLabelStyle(entry, entry.labelBaseColor, 72, 40);
            } else {
              // grayscale + slightly more transparent shading
              entry.tri.material.color.set(entry.grayColor);
              entry.shade.material.color.set(entry.grayColor);
              entry.shade.material.opacity = entry.baseOpacity * 0.5;

              // light, semi-transparent gray label (normal font size)
              setEntryLabelStyle(entry, "rgba(160,160,160,0.35)", 56, 32);
            }

            entry.tri.material.needsUpdate = true;
            entry.shade.material.needsUpdate = true;
          });

          selectedPeakEntry = selectedEntry;
        }

        // =====================
        // 8. DRAW PEAKS
        // =====================
        function drawPeaks(peaks) {
          if (!peaks.length) {
            console.warn("No peaks found from Overpass.");
            return;
          }

          const maxEle = Math.max(...peaks.map(p => p.ele || 1));

          // Color gradient: near = red, far = blue (base colors)
          const nearColor = new THREE.Color(0xff0000); // red (close)
          const farColor  = new THREE.Color(0x0000ff); // blue (far)

          // distances
          peaks.forEach(p => {
            const distMeters = haversineDistanceMeters(user.lat, user.lon, p.lat, p.lon);
            p._distMeters = distMeters;
          });

          const maxDist = Math.max(...peaks.map(p => p._distMeters || 1));

          peaks.forEach(p => {
            const ele = p.ele || 0;
            const d   = p._distMeters;

            // 0..1 distance factor (0 = near, 1 = far)
            const tDist = Math.min(1, d / maxDist);

            // 0..1: elevation & distance normalized
            const eNorm = ele / maxEle;       // taller peak → bigger
            const dNorm = 1 - tDist;          // closer → bigger

            // Blend them (elevation dominates, distance still matters)
            const weightEle  = 0.7;
            const weightDist = 0.3;
            let combined = weightEle * eNorm + weightDist * dNorm;
            combined = Math.max(0.1, combined); // avoid too tiny

            // Map combined factor into world height range
            const minH = 4;
            const maxH = 20;
            const height = minH + combined * (maxH - minH);

            const width  = 3;

            // color by distance red→blue
            const t = tDist; // 0 near, 1 far
            const col = nearColor.clone().lerp(farColor, t);
            const colHex = col.getHex();

            // grayscale version for non-selected state
            const hsl = { h: 0, s: 0, l: 0 };
            col.getHSL(hsl);
            const gray = new THREE.Color().setHSL(0, 0, hsl.l);
            const grayHex = gray.getHex();

            // line thickness by distance
            const maxThickness = 6;
            const minThickness = 1;
            const thickness = maxThickness - t * (maxThickness - minThickness);

            const tri = makeTrianglePeak(height, width, colHex, thickness);
            scene.add(tri);
            placePeakOnHorizon(tri, user, p, lineRadius, height);

            // transparent shading (slightly stronger for nearer peaks)
            let shadeOpacity = 0.35 - 0.25 * t;
            shadeOpacity = Math.max(0.05, shadeOpacity);

            const shade = makeFilledPeakTriangle(height, width, colHex, shadeOpacity);
            shade.position.copy(tri.position);
            shade.rotation.copy(tri.rotation);
            shade.position.y -= 0.05;
            scene.add(shade);

            // label placement
            const tipLocal = new THREE.Vector3(0, height, 0);
            const tipWorld = tri.localToWorld(tipLocal.clone());

            const labelOffset = 30;
            const labelPos = tipWorld.clone().add(new THREE.Vector3(0, labelOffset, 0));

            const leaderGeom = new THREE.BufferGeometry().setFromPoints([
              tipWorld,
              labelPos
            ]);
            const leaderMat  = new THREE.LineBasicMaterial({ color: 0x000000 });
            const leaderLine = new THREE.Line(leaderGeom, leaderMat);
            scene.add(leaderLine);

            // subtitle text: distance & elevation
            const distMiles = d / 1609.34;
            const distStr = distMiles.toFixed(1) + " mi";

            const eleMeters = ele;
            const eleFeet = eleMeters * 3.28084;
            const eleStr = Math.round(eleFeet).toLocaleString() + " ft";

            const subtitle = `${distStr} · ${eleStr}`;

            const labelBaseColor = "#000000";
            const label = makePeakLabel(p.name, subtitle, labelBaseColor);
            label.position.copy(labelPos);

            // *** KEY BIT: make label rotate exactly like the peak ***
            label.rotation.copy(tri.rotation);

            scene.add(label);

            // store for interaction
            peakObjects.push({
              data: p,
              tri,
              shade,
              leaderLine,
              label,
              baseColor: colHex,
              grayColor: grayHex,
              baseOpacity: shadeOpacity,
              subtitle,
              labelBaseColor
            });
          });
        }

        // =====================
        // 9. INIT PEAKS
        // =====================

        function initPeaks() {
          clearPeaks();
          setStatusLoading("Fetching peaks…");

          const radiusMeters = 80000; // Peaks search radius

          fetchPeaksFromOverpass(user.lat, user.lon, radiusMeters)
            .then(data => {
              let peaks = buildPeaksFromOverpass(data);

              peaks = peaks.filter(p => p.name && !p.name.toLowerCase().includes("unnamed"));

              peaks = filterVisiblePeaks(peaks, user, {
                binSizeDeg: 2,
                minAngleRad: 0
              });

              if (!peaks.length) {
                console.warn("No peaks found from Overpass.");
                setStatusCount(0);
                return;
              }

              console.log("Peaks after visibility filter:", peaks.length);
              drawPeaks(peaks);
              setStatusCount(peaks.length);
            })
            .catch(err => {
              console.error("Error fetching peaks from Overpass:", err);
              setStatusError("Overpass failed");
            });
        }

        function setUserToDeviceAndInit() {
          if (!navigator.geolocation) {
            alert("Geolocation not supported on this device.");
            initPeaks();
            return;
          }
          navigator.geolocation.getCurrentPosition(
            pos => {
              user = {
                lat: pos.coords.latitude,
                lon: pos.coords.longitude
              };
              updateLocationInputs();
              initPeaks();
            },
            err => {
              console.warn("Geolocation failed, using current or default location:", err);
              updateLocationInputs();
              initPeaks();
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
          );
        }

        // initial boot
        setUserToDeviceAndInit();

        // =====================
        // 10. LOCATION PANEL BUTTONS
        // =====================
        if (applyBtn) {
          // applyBtn.addEventListener('click', () => {
          //   const latVal = parseFloat(latInput.value);
          //   const lonVal = parseFloat(lonInput.value);
          //   if (!isFinite(latVal) || !isFinite(lonVal)) {
          //     alert("Please enter valid numbers for latitude and longitude.");
          //     return;
          //   }
          //   user.lat = latVal;
          //   user.lon = lonVal;
          //   initPeaks();
          // });
          applyBtn.addEventListener('click', async () => {
            const latVal = parseFloat(latInput.value);
            const lonVal = parseFloat(lonInput.value);
            const placeVal = (placeInput?.value || "").trim();

            // Prefer explicit lat/lon if both are valid
            if (isFinite(latVal) && isFinite(lonVal)) {
              user.lat = latVal;
              user.lon = lonVal;
              initPeaks();
              return;
            }

            // Otherwise try geocoding the place/zip/address
            if (placeVal) {
              const result = await geocodePlaceToLatLon(placeVal);
              if (!result) {
                alert("Couldn't find that place. Try a more specific address/city/ZIP.");
                return;
              }
              user.lat = result.lat;
              user.lon = result.lon;
              updateLocationInputs();
              initPeaks();
              return;
            }

            alert("Enter either Lat/Lon OR an address/city/ZIP in the Place box.");
          });
        }

        if (resetBtn) {
          resetBtn.addEventListener('click', () => {
            if (placeInput) placeInput.value = "";
            setUserToDeviceAndInit();
            updateLocationInputs(true); // <-- force fill now
          });
        }

        // =====================
        // 11. COMPASS INDICATORS (N/E/S/W)
        // =====================
        function makeDirectionIndicators(letter, color = "#000", fontPx = 72, size = 18) {
          const canvas = document.createElement("canvas");
          canvas.width = canvas.height = 256;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, 256, 256);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${fontPx}px sans-serif`;
          ctx.fillText(letter, 128, 128);

          const tex = new THREE.CanvasTexture(canvas);
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide
          });

          const geo = new THREE.PlaneGeometry(size, size);
          return new THREE.Mesh(geo, mat);
        }

        const dirs = [
          { label: "N", bearing: 0   },
          { label: "E", bearing: 90  },
          { label: "S", bearing: 180 },
          { label: "W", bearing: 270 }
        ];

        dirs.forEach(d => {
          const mesh = makeDirectionIndicators(d.label);
          const ang = sceneBearingRad(d.bearing);
          const r = lineRadius;

          mesh.position.set(
            r * Math.cos(ang),
            0,
            r * Math.sin(ang)
          );

          mesh.lookAt(0, 0, 0);
          scene.add(mesh);
        });

        // =====================
        // 12. RENDER LOOP
        // =====================
        function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        }
        animate();

        // =====================
        // 13. DEVICE ORIENTATION → CAMERA + PANEL SHOW/HIDE
        // =====================
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const quaternion = new THREE.Quaternion();
        const screenOrientationQuaternion = new THREE.Quaternion();
        const zAxis = new THREE.Vector3(0, 0, 1);

        const q1 = new THREE.Quaternion().setFromAxisAngle(
          new THREE.Vector3(1, 0, 0),
          -Math.PI / 2
        );

        function onDeviceOrientation(event) {
          if (event.alpha == null) return;

          const alphaRad = THREE.MathUtils.degToRad(event.alpha);
          const betaRad  = THREE.MathUtils.degToRad(event.beta);
          const gammaRad = THREE.MathUtils.degToRad(event.gamma);

          const screenAngle =
            (screen.orientation && screen.orientation.angle) || window.orientation || 0;
          const screenAngleRad = THREE.MathUtils.degToRad(screenAngle);

          euler.set(betaRad, alphaRad, -gammaRad, 'YXZ');
          quaternion.setFromEuler(euler);

          quaternion.multiply(q1);

          screenOrientationQuaternion.setFromAxisAngle(zAxis, -screenAngleRad);
          quaternion.multiply(screenOrientationQuaternion);

          camera.quaternion.copy(quaternion);

          // ---- Show panel when phone points down (toward bottom of cylinder) ----
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const lookingDown = forward.y < -0.5; // tweak threshold if needed

          if (locationPanel) {
            if (lookingDown) {
              locationPanel.style.display = 'block';
              // updateLocationInputs();
            } else {
              locationPanel.style.display = 'none';
            }
          }
        }

        window.addEventListener('deviceorientation', onDeviceOrientation, { passive: true });

        // =====================
        // 14. CLICK HANDLER (CLICK TRIANGLE / SHADE)
        // =====================
        function onClick(event) {
          const rect = renderer.domElement.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);

          // Clickable: triangle outline + shaded fill
          const clickTargets = [];
          peakObjects.forEach(p => {
            clickTargets.push(p.tri, p.shade);
          });

          const intersects = raycaster.intersectObjects(clickTargets, true);
          if (!intersects.length) return;

          const clickedObj = intersects[0].object;
          const entry = peakObjects.find(p => p.tri === clickedObj || p.shade === clickedObj);
          if (!entry) return;

          // toggle if clicking the same one again
          if (selectedPeakEntry === entry) {
            applySelection(null);
          } else {
            applySelection(entry);
          }
        }

        renderer.domElement.addEventListener('click', onClick, false);
    </script>
</body>
</html>
