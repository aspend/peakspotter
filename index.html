<!DOCTYPE html>
<html>
<head>
    <title>Peaks Viewer</title>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // =====================
        // 1. CREATE WORLD
        // =====================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        scene.background = new THREE.Color(0xFFFFFF);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Default user location (fallback: your old hardcoded one)
        let user = { lat: 37.7380151, lon: -122.4299151 };

        // =====================
        // 2. CYLINDER + HORIZON
        // =====================
        const cylinderRadius = 100;
        const cylinderHeight = 100;
        const radialSegments = 360;

        const cylinderGeometry = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderHeight,
          radialSegments
        );
        const cylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        scene.add(cylinder);

        // Horizon line
        const linePoints = [];
        const lineRadius = cylinderRadius;
        const lineHeight = 0;

        for (let i = 0; i <= radialSegments; i++) {
          const angle = (i / radialSegments) * Math.PI * 2;
          const x = lineRadius * Math.cos(angle);
          const z = lineRadius * Math.sin(angle);
          linePoints.push(new THREE.Vector3(x, lineHeight, z));
        }

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        // =====================
        // 3. BEARING HELPERS
        // =====================
        const toRad = d => d * Math.PI / 180;
        const toDeg = r => r * 180 / Math.PI;

        function compassBearingDeg(lat1, lon1, lat2, lon2) {
          const latr1 = toRad(lat1), latr2 = toRad(lat2);
          const dLon = toRad(lon2 - lon1);

          const y = Math.sin(dLon) * Math.cos(latr2);
          const x = Math.cos(latr1) * Math.sin(latr2) -
                    Math.sin(latr1) * Math.cos(latr2) * Math.cos(dLon);
          return (toDeg(Math.atan2(y, x)) + 360) % 360; // 0..360, 0 = North
        }

        const sceneBearingRad = bearing => THREE.MathUtils.degToRad(bearing - 90);

        function placePeakOnHorizon(obj, user, peak, radius, height = 2) {
          const brg = compassBearingDeg(user.lat, user.lon, peak.lat, peak.lon);
          const ang = sceneBearingRad(brg);

          obj.position.set(
            radius * Math.cos(ang),
            0, // base on horizon
            radius * Math.sin(ang)
          );

          obj.lookAt(0, 0, 0);
        }

        // add distance and vertical angle helpers
        // Great-circle distance in meters
        function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
          const R = 6371000; // Earth radius in meters
          const φ1 = toRad(lat1);
          const φ2 = toRad(lat2);
          const Δφ = toRad(lat2 - lat1);
          const Δλ = toRad(lon2 - lon1);

          const a =
            Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);

          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        // Approximate vertical elevation angle from user → peak (radians)
        function verticalAngleRad(user, peak) {
          const userEle = user.ele || 0;              // if you ever get real user elevation, put it here
          const peakEle = peak.ele || userEle;
          const d = haversineDistanceMeters(user.lat, user.lon, peak.lat, peak.lon);
          if (d === 0) return 0;
          const deltaH = peakEle - userEle;           // height difference in meters
          return Math.atan2(deltaH, d);               // vertical angle above horizon
        }


        // add visibility filter for peaks
        function filterVisiblePeaks(peaks, user, options = {}) {
          const binSizeDeg   = options.binSizeDeg   || 2;           // angular resolution
          const minAngleRad  = options.minAngleRad  ?? -Infinity;   // set e.g. 0 to drop below-horizon peaks

          const withMeta = peaks.map(p => {
            const bearing = compassBearingDeg(user.lat, user.lon, p.lat, p.lon);
            const vAngle  = verticalAngleRad(user, p);
            return { ...p, bearing, vAngle };
          });

          // Optionally drop stuff clearly below horizon:
          const candidates = withMeta.filter(p => p.vAngle >= minAngleRad);

          const bestByBin = new Map();

          candidates.forEach(p => {
            const bin = Math.round(p.bearing / binSizeDeg) * binSizeDeg;
            const current = bestByBin.get(bin);
            if (!current || p.vAngle > current.vAngle) {
              bestByBin.set(bin, p);
            }
          });

          return Array.from(bestByBin.values());
        }


        // =====================
        // 4. PEAK GEOMETRY + LABELS
        // =====================
        function makeTrianglePeak(height, width, color = 0x000000) {
          const halfW = width / 2;
          const points = [
            new THREE.Vector3(-halfW, 0, 0),
            new THREE.Vector3(0,      height, 0),
            new THREE.Vector3(halfW,  0, 0),
            new THREE.Vector3(-halfW, 0, 0),
          ];

          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const mat  = new THREE.LineBasicMaterial({ color });
          return new THREE.Line(geom, mat);
        }

        // function makePeakLabel(text, color = "#000", fontPx = 50, size = 10) {
        //   const canvas = document.createElement("canvas");
        //   canvas.width = canvas.height = 256;
        //   const ctx = canvas.getContext("2d");

        //   ctx.clearRect(0, 0, 256, 256);
        //   ctx.fillStyle = color;
        //   ctx.textAlign = "center";
        //   ctx.textBaseline = "middle";
        //   ctx.font = `bold ${fontPx}px sans-serif`;
        //   ctx.fillText(text, 128, 128);

        //   const texture = new THREE.CanvasTexture(canvas);
        //   const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        //   const sprite = new THREE.Sprite(material);

        //   sprite.scale.set(size, size * 2, 2);
        //   return sprite;
        // }

//         function makePeakLabel(text, color = "#000", fontPx = 50, size = 10) {
//           const canvas = document.createElement("canvas");
//           canvas.width = canvas.height = 256;
//           const ctx = canvas.getContext("2d");

//           ctx.clearRect(0, 0, 256, 256);
//           ctx.fillStyle = color;
//           ctx.textAlign = "center";
//           ctx.textBaseline = "middle";
//           ctx.font = `bold ${fontPx}px sans-serif`;

//           // ---- ROTATE SLIGHTLY OFF-VERTICAL ----
//           // Full vertical = -90° (straight up/down)
//           // 30° off vertical = -60°
//           const angle = -60 * Math.PI / 180;  // -60 degrees
//           ctx.save();
//           ctx.translate(canvas.width / 2, canvas.height / 2);
//           ctx.rotate(angle);
//           ctx.fillText(text, 0, 0);
//           ctx.restore();

//           const texture = new THREE.CanvasTexture(canvas);
//           const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
//           const sprite = new THREE.Sprite(material);

//           // Taller scale since text is angled
//           sprite.scale.set(size, size * 3, 1);

//           return sprite;
// }
        function makePeakLabel(
          text,
          color = "#000",
          {
            fontPx = 48,      // base font size in CSS pixels
            sizeWorld = 12,   // how big the label is in your 3D world units
            angleDeg = -60    // rotation of the text on the canvas (30° off vertical)
          } = {}
        ) {
          const dpr = window.devicePixelRatio || 1;

          // Logical canvas size in CSS pixels (we'll scale by DPR for sharpness)
          const logicalSize = 512;
          const canvas = document.createElement("canvas");
          canvas.width = logicalSize * dpr;
          canvas.height = logicalSize * dpr;

          const ctx = canvas.getContext("2d");

          // Map 0..logicalSize coords to the high-res backing store
          ctx.scale(dpr, dpr);

          // Clean, modern font
          ctx.clearRect(0, 0, logicalSize, logicalSize);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          // We'll possibly shrink the font if the word is too long
          let currentFontPx = fontPx;
          const setFont = () => {
            ctx.font = `600 ${currentFontPx}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
          };
          setFont();

          // Measure and auto-shrink to avoid clipping
          const padding = 40; // leave margin so rotated text doesn't hit the canvas edge
          let metrics = ctx.measureText(text);
          let textWidth = metrics.width;
          const maxWidth = logicalSize - 2 * padding;

          if (textWidth > maxWidth) {
            const scale = maxWidth / textWidth;
            currentFontPx = currentFontPx * scale;
            setFont();
            metrics = ctx.measureText(text);
            textWidth = metrics.width;
          }

          // Rotate slightly off vertical and draw text
          ctx.save();
          ctx.translate(logicalSize / 2, logicalSize / 2);
          const angleRad = angleDeg * Math.PI / 180; // e.g. -60°
          ctx.rotate(angleRad);
          ctx.fillText(text, 0, 0);
          ctx.restore();

          // Create THREE texture with better filtering
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.anisotropy =
            (renderer.capabilities && renderer.capabilities.getMaxAnisotropy
              ? renderer.capabilities.getMaxAnisotropy()
              : 1);
          texture.needsUpdate = true;

          const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true
          });

          const sprite = new THREE.Sprite(material);

          // World size of the label: keep this roughly proportional to what you want on-screen
          sprite.scale.set(sizeWorld, sizeWorld * 3, 1);

          return sprite;
        }


        // =====================
        // 5. OVERPASS API: FETCH PEAKS
        // =====================

        // Fetch "natural=peak" within radiusMeters of (lat, lon)
        function fetchPeaksFromOverpass(lat, lon, radiusMeters = 50000) {
          const query = `
            [out:json][timeout:25];
            node["natural"="peak"](around:${radiusMeters},${lat},${lon});
            out body;
          `;

          return fetch("https://overpass-api.de/api/interpreter", {
            method: "POST",
            body: query
          }).then(res => res.json());
        }

        // Convert Overpass JSON -> peaks array in your format
        function buildPeaksFromOverpass(json) {
          if (!json.elements) return [];

          return json.elements
            .filter(el => el.type === "node")
            .map(el => {
              const tags = el.tags || {};
              const ele = tags.ele ? parseFloat(tags.ele) : null;

              return {
                name: tags.name || "Unnamed peak",
                lat: el.lat,
                lon: el.lon,
                ele: Number.isFinite(ele) ? ele : 1000, // fallback if no elevation
                color: 0x0000ff
              };
            });
        }

        // Draw peaks (triangles + labels) once we have them
        function drawPeaks(peaks) {
          if (!peaks.length) {
            console.warn("No peaks found from Overpass.");
            return;
          }

          const maxEle = Math.max(...peaks.map(p => p.ele || 1));

          peaks.forEach(p => {
            // 1) decide mountain visual size in world units
            const height = 10 * p.ele / maxEle;   // same idea as before
            const width  = 3;

            // 2) create triangle outline and place it on the horizon
            const tri = makeTrianglePeak(height, width, p.color || 0x0000ff);
            scene.add(tri);
            placePeakOnHorizon(tri, user, p, lineRadius, height);

            // 3) find the peak TIP in world coordinates
            // local tip is (0, height, 0) in the triangle’s own space
            const tipLocal = new THREE.Vector3(0, height, 0);
            const tipWorld = tri.localToWorld(tipLocal.clone());

            // 4) define where the label should go:
            //    move "up" in world Y from the tip (toward top of screen when horizon is centered)
            const labelOffset = 30; // tweak this number to move label higher/lower
            const labelPos = tipWorld.clone().add(new THREE.Vector3(0, labelOffset, 0));

            // 5) draw a line from peak tip to label position
            const leaderGeom = new THREE.BufferGeometry().setFromPoints([
              tipWorld,
              labelPos
            ]);
            const leaderMat  = new THREE.LineBasicMaterial({ color: 0x000000 });
            const leaderLine = new THREE.Line(leaderGeom, leaderMat);
            scene.add(leaderLine);

            // 6) create label at the end of that line
            const label = makePeakLabel(p.name, "#000");
            label.position.copy(labelPos);
            scene.add(label);
          });
        }

        // =====================
        // 6. GET USER LOCATION, THEN LOAD PEAKS
        // =====================
        // function initPeaks() {
        //   const radiusMeters = 50000; // ~50 miles
        //   fetchPeaksFromOverpass(user.lat, user.lon, radiusMeters)
        //     .then(data => {
        //       const peaks = buildPeaksFromOverpass(data);
        //       drawPeaks(peaks);
        //     })
        //     .catch(err => {
        //       console.error("Error fetching peaks from Overpass:", err);
        //     });
        // }


        function initPeaks() {
          const radiusMeters = 50000; // ~50 miles
          fetchPeaksFromOverpass(user.lat, user.lon, radiusMeters)
            .then(data => {
              let peaks = buildPeaksFromOverpass(data);

              // ⬇️ reduce to “visible” / dominant peaks
              peaks = filterVisiblePeaks(peaks, user, {
                binSizeDeg: 2,      // try 1–5° and see what looks good
                minAngleRad: 0      // 0 = only above-horizon; use -Infinity to keep all
              });

              console.log("Peaks after visibility filter:", peaks.length);
              drawPeaks(peaks);
            })
            .catch(err => {
              console.error("Error fetching peaks from Overpass:", err);
            });
        }

        // Try to get real device location; fall back to default if denied
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            pos => {
              user = {
                lat: pos.coords.latitude,
                lon: pos.coords.longitude
              };
              initPeaks();
            },
            err => {
              console.warn("Geolocation failed, using default location:", err);
              initPeaks();
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
          );
        } else {
          console.warn("Geolocation not supported, using default location.");
          initPeaks();
        }

        // =====================
        // 7. COMPASS INDICATORS (N/E/S/W)
        // =====================
        function makeDirectionIndicators(letter, color = "#000", fontPx = 72, size = 18) {
          const canvas = document.createElement("canvas");
          canvas.width = canvas.height = 256;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, 256, 256);
          ctx.fillStyle = color;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${fontPx}px sans-serif`;
          ctx.fillText(letter, 128, 128);

          const tex = new THREE.CanvasTexture(canvas);
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide
          });

          const geo = new THREE.PlaneGeometry(size, size);
          return new THREE.Mesh(geo, mat);
        }

        const dirs = [
          { label: "N", bearing: 0   },
          { label: "E", bearing: 90  },
          { label: "S", bearing: 180 },
          { label: "W", bearing: 270 }
        ];

        dirs.forEach(d => {
          const mesh = makeDirectionIndicators(d.label);
          const ang = sceneBearingRad(d.bearing);
          const r = lineRadius;

          mesh.position.set(
            r * Math.cos(ang),
            0,
            r * Math.sin(ang)
          );

          mesh.lookAt(0, 0, 0);
          scene.add(mesh);
        });

        // =====================
        // 8. RENDER LOOP
        // =====================
        function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        }
        animate();

        // =====================
        // 9. DEVICE ORIENTATION → CAMERA
        // =====================
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const quaternion = new THREE.Quaternion();
        const screenOrientationQuaternion = new THREE.Quaternion();
        const zAxis = new THREE.Vector3(0, 0, 1);

        const q1 = new THREE.Quaternion().setFromAxisAngle(
          new THREE.Vector3(1, 0, 0),
          -Math.PI / 2
        );

        function onDeviceOrientation(event) {
          if (event.alpha == null) return;

          const alphaRad = THREE.MathUtils.degToRad(event.alpha);
          const betaRad  = THREE.MathUtils.degToRad(event.beta);
          const gammaRad = THREE.MathUtils.degToRad(event.gamma);

          const screenAngle =
            (screen.orientation && screen.orientation.angle) || window.orientation || 0;
          const screenAngleRad = THREE.MathUtils.degToRad(screenAngle);

          euler.set(betaRad, alphaRad, -gammaRad, 'YXZ');
          quaternion.setFromEuler(euler);

          quaternion.multiply(q1);

          screenOrientationQuaternion.setFromAxisAngle(zAxis, -screenAngleRad);
          quaternion.multiply(screenOrientationQuaternion);

          camera.quaternion.copy(quaternion);
        }

        window.addEventListener('deviceorientationabsolute', onDeviceOrientation, { passive: true });
    </script>
</body>
</html>
